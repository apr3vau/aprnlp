;; -*- mode: Lisp; coding: utf-8-unix; -*-
;; Copyright (c) 2024, April & May
;; SPDX-License-Identifier: 0BSD

(in-package aprnlp)

(defclass pos-tagger (perceptron-processor)
  ((name             :initform "unnamed-pos-tagger")
   (unique-tag-words :initform (make-hash-table :test #'eq))))

(defparameter *loaded-pos-tagger* nil)

;; Features

(defun prev-word (i words)
  (declare (inline prev-word))
  (if (< i 1) :start (word-form (aref words (1- i)))))
(defun prev-prev-word (i words)
  (declare (inline prev-prev-word))
  (if (< i 2) :start (word-form (aref words (- i 2)))))
(defun next-word (i words)
  (declare (inline next-word))
  (if (> i (- (length words) 2)) :end (word-form (aref words (1+ i)))))
(defun next-next-word (i words)
  (declare (inline next-next-word))
  (if (> i (- (length words) 3)) :end (word-form (aref words (+ i 2)))))

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defparameter *backward-features*
    '((:word           form     t)
      (:prev-word      form     (prev-word i words))
      (:prev-prev-word form     (prev-prev-word i words))
      (:next-word      form     (next-word i words))
      (:next-next-word form     (next-next-word i words))
      (:word           t        t)
      (:prev-word      t        (prev-word i words))
     ;(:prev-prev-word t        (prev-prev-word i words))
      (:next-word      t        (next-word i words))
     ;(:next-next-word t        (next-next-word i words))
     ;(:suffix         form     (suffix form))
     ;(:prefix         form     (prefix form))
      (:suffix         t        (word-suffix word))
      (:prefix         t        (word-prefix word))
     ;(:prev-suffix    form     (suffix (prev-word i words)))
     ;(:next-suffix    form     (suffix (next-word i words)))
      (:prev-suffix    t        (if (< i 1) 'start (word-suffix (aref words (1- i)))))
      (:next-suffix    t        (if (> i (- (length words) 2)) 'end (word-suffix (aref words (1+ i)))))
      (:prev-tag       form     prev-tag)
     ;(:prev-prev-tag  form     prev-prev-tag)
      (:prev-tag       t        prev-tag)
     ;(:prev-prev-tag  t        prev-prev-tag)
      (:prev-tags      prev-tag prev-prev-tag))))

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defparameter *forward-features*
    '((:next-tag      form     next-tag)
     ;(:next-next-tag form     next-next-tag)
      (:next-tag      t        next-tag)
     ;(:next-next-tag t        next-next-tag)
      (:next-tags next-tag next-next-tag))))

(macrolet ((expand (features)
             (let ((features (eval features)))
               `(let ((i (1- (word-id word)))
                      (form (general-form word)))
                  (declare (ignorable i))
                  (vector ,@(for (feature :in features)
                                 (collect `(list ,@feature))))))))
  (defun pos-backward-features (word words prev-tag prev-prev-tag)
    (declare (optimize (speed 3) (safety 0)))
    (expand *backward-features*))
  (defun pos-forward-features (word words next-tag next-next-tag)
    (declare (optimize (speed 3) (safety 0))
             (ignore words))
    (expand *forward-features*))
  (defun pos-all-features (word words prev-tag prev-prev-tag next-tag next-next-tag)
    (declare (optimize (speed 3) (safety 0)))
    (expand (append *backward-features* *forward-features*))))

;; Methods

(defmethod process ((tagger pos-tagger) sentence)
  (declare (optimize (speed 3) (space 0) (safety 0)))
  (with-slots (weights unique-tag-words) tagger
    (let ((scores (make-array (length sentence) :element-type 'hash-table)))
      (for (prev-tag :previous tag 'start)
           (prev-prev-tag :previous prev-tag 'start)
           (i :index)
           (word :across sentence)
           (form := (word-form word))
           (unique-tag := (gethash form unique-tag-words))
           (tag := unique-tag)
           (setf (svref scores i) (make-hash-table :test #'eq))
           (if unique-tag
               (setf (gethash unique-tag (svref scores i)) most-positive-fixnum)
             (for (feature :across (pos-backward-features word sentence prev-tag prev-prev-tag))
                  (when-let (table (apply #'href-default nil weights feature))
                    (for (class weight :in-table table)
                         (incf (gethash class (svref scores i) 0.0) weight)))
                  (:final (setq tag (for (class weight :in-table (svref scores i))
                                         (:find class :max weight)))))))
      (for (next-tag :previous tag 'end)
           (next-next-tag :previous next-tag 'end)
           (i :range (1- (length sentence)) 0)
           (word       := (aref sentence i))
           (form       := (word-form word))
           (unique-tag := (gethash form unique-tag-words))
           (tag        := unique-tag)
           (unless unique-tag
             (for (feature :across (pos-forward-features word sentence next-tag next-next-tag))
                  (when-let (table (apply #'href-default nil weights feature))
                    (for (class weight :in-table table)
                         (incf (gethash class (svref scores i) 0.0) weight)))
                  (:final (setq tag (for (class weight :in-table (svref scores i))
                                         (:find class :max weight)))))))
      (for (table :across scores)
           (collect (for (class weight :in-table table)
                         (:find class :max weight)))))))

(defmethod load-processor ((class (eql 'pos-tagger)) file)
  #+lispworks (hcl:load-data-file file)
  #-lispworks (load file)
  *loaded-pos-tagger*)

(defmethod save-processor ((tagger pos-tagger) directory)
  (with-slots (name weights unique-tag-words) tagger
    (let ((filename (make-pathname :name name :type "fasl" :defaults directory)))
      #+lispworks
      (hcl:with-output-to-fasl-file (out filename :overwrite t)
        (hcl:dump-form '(setf *loaded-pos-tagger* (make-instance 'pos-tagger)) out)
        (hcl:dump-form `(setf (slot-value *loaded-pos-tagger* 'name) ,name) out)
        (hcl:dump-form `(setf (slot-value *loaded-pos-tagger* 'weights)
                              (plist-to-table ',(table-to-plist weights)))
                       out)
        (hcl:dump-form `(setf (slot-value *loaded-pos-tagger* 'unique-tag-words)
                              (plist-to-table ',(table-to-plist unique-tag-words)))
                       out))
      #-lispworks
      (let ((src (make-pathname :name name :type "lisp" :defaults directory)))
        (with-open-file (out src
                             :direction :output
                             :if-exists :supersede
                             :if-does-not-exist :create)
          (prin1 '(setf *loaded-pos-tagger* (make-instance 'pos-tagger)) out)
          (prin1 `(setf (slot-value *loaded-pos-tagger* 'name) ,name) out)
          (prin1 `(setf (slot-value *loaded-pos-tagger* 'weights)
                        (plist-to-table ',(table-to-plist weights)))
                 out)
          (prin1 `(setf (slot-value *loaded-pos-tagger* 'unique-tag-words)
                        (plist-to-table ',(table-to-plist unique-tag-words)))
                 out))
        (compile-file src :output-file filename)
        (delete-file src))
      (log-info "Tagger saved to ~A, size: ~A" (namestring filename) (print-size (file-size-in-octets filename)))
      *loaded-pos-tagger*)))

(defmethod train ((tagger pos-tagger) sentences &key (cycles 5) save-dir)
  (declare (optimize (speed 3) (space 0) (safety 0)))
  (with-slots (unique-tag-words) tagger
    (unless save-dir
      (setq save-dir (asdf/system:system-source-directory :aprnlp)))
    (log-info "Start training with ~D sentences, ~D cycles. "
              (length sentences) cycles
              #+lispworks (lw:string-append "Heap size: " (print-size (getf (sys:room-values) :total-size)))
              #-lispworks "")
    (let ((table (make-hash-table :test #'eq)))
      (for* (sentence :across sentences)
            (word :across sentence)
            (incf (getf (gethash (word-form word) table) (word-upos word) 0)))
      (for (form plist :in-table table)
           (if (> (length plist) 2)
               (remhash form table)
             (setf (gethash form table) (first plist))))
      (setf unique-tag-words table)
      (log-info "Found ~A words has unique tag." (hash-table-count table)))
    (for (cycle :range cycles)
         (let ((correct-count    0)
               (total-count      0)
               (cycle-start-time (get-internal-real-time)))
           (for (sentence :across sentences)
                (guesses := (process tagger sentence))
                (for (prev-tag      :prev   guess 'start)
                     (prev-prev-tag :prev   prev-tag 'start)
                     (i             :index)
                     (word          :across sentence)
                     (guess         :in     guesses)
                     (truth         :=      (word-upos word))
                     (features      :=      (pos-all-features word sentence prev-tag prev-prev-tag
                                                              (nth (1+ i) guesses) (nth (+ 2 i) guesses)))
                     (update tagger truth guess features)
                     (when (eq guess truth) (incf correct-count))
                     (incf total-count)))
           (shuffle sentences)
           (log-info "Cycle ~D/~D completed using ~,2Fs with ~D/~D (~,2F%) correct. ~A"
                     (1+ cycle) cycles
                     #+lispworks (/ (- (get-internal-real-time) cycle-start-time) 1000)
                     #-lispworks (/ (- (get-internal-real-time) cycle-start-time) 1000000)
                     correct-count total-count (* 100.0 (/ correct-count total-count))
                     #+lispworks (lw:string-append "Heap size: " (print-size (getf (sys:room-values) :total-size)))
                     #-lispworks "")))
    (average-weights tagger)
    (save-processor tagger save-dir)))

(defmethod test ((tagger pos-tagger) sentences)
  (let ((correct-count       0)
        (total-count         0)
        (wrong-predict-table (make-hash-table :test #'eq))
        (start-time          (get-internal-real-time)))
    (for (sentence :across sentences)
         (for (word :across sentence)
              (guess :in (process tagger sentence))
              (truth = (word-upos word))
              (if (eq guess truth)
                  #|(or (eq guess truth)
                      (and (member guess '(:noun :propn))
                           (member truth '(:noun :propn))))|#
                (incf correct-count)
                (incf (getf (gethash truth wrong-predict-table) guess 0)))
              (incf total-count)))
    (log-info "Test ~D sentences using ~,2Fs, result: ~D/~D (~,2F%)"
              (length sentences)
              #+lispworks (/ (- (get-internal-real-time) start-time) 1000)
              #-lispworks (/ (- (get-internal-real-time) start-time) 1000000)
              correct-count total-count (* 100 (/ correct-count total-count)))
    (values (float (* 100 (/ correct-count total-count)))
            wrong-predict-table)))

(defmethod test-training ((class (eql 'pos-tagger)))
  (download-ud-treebanks)
  (let ((tagger (make-instance 'pos-tagger))
        (ud-dir (merge-pathnames "ud-treebanks-v2.14/" (asdf:system-source-directory :aprnlp))))
    (train tagger (read-conllu-files (merge-pathnames "UD_English-GUM/en_gum-ud-train.conllu" ud-dir)
                                     (merge-pathnames "UD_English-EWT/en_ewt-ud-train.conllu" ud-dir)
                                     (merge-pathnames "UD_English-Atis/en_atis-ud-train.conllu" ud-dir))
           :cycles 5)
    (test tagger (read-conllu-files (merge-pathnames "UD_English-GUM/en_gum-ud-test.conllu" ud-dir)))
    (setq *loaded-pos-tagger* tagger)))

;(test-training 'pos-tagger)