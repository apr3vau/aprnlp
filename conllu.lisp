(in-package pos)

(defstruct word id form lemma upos xpos head deprel suffix prefix)

(defpackage pos/words)

(defun parse-conllu-line (line id)
  (declare (inline parse-conllu-line))
  (destructuring-bind (conllu-id form lemma upos xpos feats head deprel deps misc)
      (split-sequence #\Tab line)
    (declare (ignore deps misc feats))
    (unless (find #\- conllu-id)
      (make-word :id id
                 :form (intern form "POS/WORDS")
                 :lemma (unless (eql (char lemma 0) #\_) lemma)
                 :upos (intern (string-upcase upos) :keyword)
                 :xpos (intern (string-upcase xpos) :keyword)
                 :head (unless (eql (char head 0) #\_) (parse-integer head))
                 :deprel (unless (eql (char deprel 0) #\_) (intern (string-upcase deprel) :keyword))
                 :suffix (intern (subseq form (- (length form) (min 3 (length form)))) "POS/WORDS")
                 :prefix (intern (subseq form 0 (min 3 (length form))) "POS/WORDS")))))

(defun read-conllu-stream (in)
  (declare (inline read-conllu-stream))
  (let ((result (make-array 0 :element-type 'vector :fill-pointer t :adjustable t))(i 1)
        (arr (make-array 0 :element-type 'word :fill-pointer t :adjustable t)))
    (for (line = (read-line in nil))
         (while line)
         (when (and (= (length line) 0))
           (setq i 1)
           (when (> (length arr) 0)
             (vector-push-extend arr result)
             (setq arr (make-array 0 :element-type 'word :fill-pointer t :adjustable t))))
         (when (and (> (length line) 0)
                    (not (eq (char line 0) #\#)))
           (when-let ((word (parse-conllu-line line i)))
             (vector-push-extend word arr)
             (incf i))))
    result))

(defun read-conllu-file (path)
  (declare (inline read-conllu-file))
  (with-open-file (in path :if-does-not-exist nil)
    (read-conllu-stream in)))

(defun read-conllu-files (&rest paths)
  (apply #'concatenate 'vector (mapcar #'read-conllu-file paths)))