(in-package pos)

(defun print-size (num)
  (if (numberp num)
      (cond ((< num 1024)
             (format nil "~dB" num))
            ((< num 1048576)
             (format nil "~,1fK" (/ num 1024)))
            ((< num 1073741824)
             (format nil "~,1fM" (/ num 1048576)))
            (t (format nil "~,1fG" (/ num 1073741824))))
    ""))

(defstruct pos-tagger
  (name "Unnamed")
  (update-count 0)
  (weights (make-hash-table :test #'eq))
  (last-updates (make-hash-table :test #'eq))
  (living-weights (make-hash-table :test #'eq))
  (unique-tag-words (make-hash-table :test #'eq))
  ;(feature-modifiers (make-hash-table :test #'equal))
  )

(defun table-to-plist (table)
  (for (key val :in-table table)
       (if (hash-table-p val)
           (:nconc (list key (table-to-plist val)))
         (:nconc (list key val)))))

(defun plist-to-table (plist)
  (let ((table (make-hash-table :test #'eq)))
    (for (key val :in-plist plist)
         (if (consp val)
             (setf (gethash key table) (plist-to-table val))
           (setf (gethash key table) val)))
    table))

(time (table-to-plist (pos-tagger-weights *loaded-tagger*)))

(defvar *loaded-tagger* nil)

(defun save-tagger (tagger directory)
  (with-output-to-fasl-file (out (make-pathname :name (pos-tagger-name tagger) :type "fasl"
                                                :defaults directory)
                                 :overwrite t)
    (dump-form '(setf *loaded-tagger* (make-pos-tagger)) out)
    (dump-form `(setf (pos-tagger-name *loaded-tagger*) ,(pos-tagger-name tagger)) out)
    (dump-form `(setf (pos-tagger-weights *loaded-tagger*)
                      (plist-to-table ',(table-to-plist (pos-tagger-weights tagger))))
               out)
    (dump-form `(setf (pos-tagger-unique-tag-words *loaded-tagger*)
                      (plist-to-table ',(table-to-plist (pos-tagger-unique-tag-words tagger))))
               out))
  (log-info "Tagger saved, size: ~A"
            (print-size (sys:file-size (make-pathname :name (pos-tagger-name tagger) :type "fasl"
                                                      :defaults directory)))))

(defun load-tagger (name directory)
  (load-data-file (make-pathname :name name :type "fasl" :defaults directory))
  *loaded-tagger*)

(defun suffix (form)
  (setq form (symbol-name form))
  (intern (subseq form (- (length form) (min 3 (length form)))) "POS/WORDS"))
(defun prefix (form)
  (setq form (symbol-name form))
  (intern (subseq form 0 (min 3 (length form))) "POS/WORDS"))

(defun prev-word (i words)
  (declare (inline prev-word))
  (if (< i 1) 'start (word-form (aref words (1- i)))))
(defun prev-prev-word (i words)
  (declare (inline prev-prev-word))
  (if (< i 2) 'start (word-form (aref words (- i 2)))))
(defun next-word (i words)
  (declare (inline next-word))
  (if (> i (- (length words) 2)) 'end (word-form (aref words (1+ i)))))
(defun next-next-word (i words)
  (declare (inline next-next-word))
  (if (> i (- (length words) 3)) 'end (word-form (aref words (+ i 2)))))

#|(defun feature-and-modifier (tagger feature)
  (declare (inline feature-and-modifier))
  (list feature (gethash feature (pos-tagger-feature-modifiers tagger) 1)))|#

(defun ordinalp (str)
  (declare (inline ordinalp))
  (if (symbolp str) (setq str (symbol-name str)))
  (let* ((len (length str)))
    (and (> len 2)
         (every #'digit-char-p (subseq str 0 (- len 2)))
         (member (subseq str (- len 2) len) '("st" "nd" "rd" "th")))))

(defun punctp (str)
  (declare (inline punctp))
  (if (symbolp str) (setq str (symbol-name str)))
  (and (every #'graphic-char-p str)
       (notany #'(lambda (c) (or (whitespace-char-p c)
                                 (alphanumericp c)))
               str)))

(defun collect-features (word words prev-tag prev-prev-tag)
  (declare (optimize (safety 0)))
  (let ((i (1- (word-id word)))
        (form (let ((form (word-form word)))
                (cond ((every #'digit-char-p (symbol-name form)) 'number)
                      ((ordinalp form) 'ordinal)
                      ((punctp form) 'punct)
                      (t form))))
        (vec (make-array 9 :element-type 'vector)))
    (macrolet ((makevec (type specializer value)
                 `(let ((vec (make-array 3 :element-type 'symbol)))
                    (setf (svref vec 0) ,type
                          (svref vec 1) ,specializer
                          (svref vec 2) ,value)
                    vec)))
      (setf (svref vec 0) (makevec :word form t)
            (svref vec 1) (makevec :prev-word form (prev-word i words))
            (svref vec 2) (makevec :prev-prev-word form (prev-prev-word i words))
            (svref vec 3) (makevec :next-word form (next-word i words))
            (svref vec 4) (makevec :next-next-word form (next-next-word i words))
            (svref vec 5) (makevec :prev-tag form (symbol-name prev-tag))
            (svref vec 6) (makevec :word t t)
            (svref vec 7) (makevec :prev-word t (rev-word i words))
            (svref vec 8) (makevec :next-word t (next-word i words))
          ;(makevec :prev-prev-tag prev-prev-tag form)
          ;(makevec :prev-prev-and-prev-tag form (string-append prev-prev-tag prev-tag))
          ;(makevec :prev-tag prev-tag)
          ;(makevec :prev-prev-tag prev-prev-tag)
            )
      vec)))

;(list :suffix (suffix (word-form word)) form)
;(list :prev-suffix (if (< i 1) 'start (suffix (word-form (aref words (1- i))))) form)
;(list :next-suffix (if (> i (- len 2)) 'start (suffix (word-form (aref words (1+ i))))) form)
;(list :prefix (prefix form) form)

(defun predict (tagger features)
  (declare (optimize (speed 3) (space 0) (safety 0)))
  (let ((scores (make-hash-table :test #'eq)))
    (for (feature :across features)
         (type = (svref feature 0))
         (specializer = (svref feature 1))
         (value = (svref feature 2))
         (type-table = (gethash type (pos-tagger-weights tagger)))
         (specializer-table = (when type-table (gethash specializer type-table)))
         (value-table = (when specializer-table (gethash value specializer-table)))
         (when value-table
           (for (class weight :in-table value-table)
                (if (gethash class scores)
                    (incf (gethash class scores) weight)
                  (setf (gethash class scores) weight)))))
    (let ((max-weight 0) result)
      (for (class weight :in-table scores)
           (when (> weight max-weight)
             (setq result class
                   max-weight weight)))
      result)))

(defun get-weight (table feature class)
  (declare (inline get-weight))
  (let ((type (svref feature 0))
        (specializer (svref feature 1))
        (value (svref feature 2)))
    (if-let (table (gethash type table))
        (if-let (table (gethash specializer table))
            (if-let (table (gethash value table))
                (gethash class table 0)
              0)
          0)
      0)))

(defun add-weight (table feature class val)
  (declare (optimize (safety 0) (speed 3) (space 0)))
  (let ((type (svref feature 0))
        (specializer (svref feature 1))
        (value (svref feature 2)))
    (prog (type-table specializer-table value-table)
     (if-let (table (gethash type table))
         (progn
           (setq type-table table)
           (if-let (table (gethash specializer table))
               (progn
                 (setq specializer-table table)
                 (if-let (table (gethash value table))
                     (progn
                       (setq value-table table)
                       (go set-value))
                   (go create-value-table)))
             (go create-specializer-table)))
       (go create-type-table))
     create-type-table
     (setq type-table (setf (gethash type table) (make-hash-table :test #'eq)))
     create-specializer-table
     (setq specializer-table (setf (gethash specializer type-table) (make-hash-table :test #'eq)))
     create-value-table
     (setq value-table (setf (gethash value specializer-table) (make-hash-table :test #'eq)))
     set-value
     (setf (gethash class value-table) (+ val (gethash class value-table 0))))))

(defun set-weight (table feature class val)
  (declare (optimize (safety 0) (speed 3) (space 0)))
  (let ((type (svref feature 0))
        (specializer (svref feature 1))
        (value (svref feature 2)))
    (prog (type-table specializer-table value-table)
     (if-let (table (gethash type table))
         (progn
           (setq type-table table)
           (if-let (table (gethash specializer table))
               (progn
                 (setq specializer-table table)
                 (if-let (table (gethash value table))
                     (progn
                       (setq value-table table)
                       (go set-value))
                   (go create-value-table)))
             (go create-specializer-table)))
       (go create-type-table))
     create-type-table
     (setq type-table (setf (gethash type table) (make-hash-table :test #'eq)))
     create-specializer-table
     (setq specializer-table (setf (gethash specializer type-table) (make-hash-table :test #'eq)))
     create-value-table
     (setq value-table (setf (gethash value specializer-table) (make-hash-table :test #'eq)))
     set-value
     (setf (gethash class value-table) val))))

(defun update (tagger truth guess features)
  (declare (optimize (speed 3) (space 0) (safety 0)))
  (flet ((upd (feature class val)
           (declare (inline upd))
           (let* ((update-count (pos-tagger-update-count tagger))
                  (last-update (get-weight (pos-tagger-last-updates tagger) feature class))
                  (lived-cycle (- update-count last-update)))
             (add-weight (pos-tagger-living-weights tagger) feature class
                         (* lived-cycle (get-weight (pos-tagger-weights tagger) feature class)))
             (set-weight (pos-tagger-last-updates tagger) feature class update-count)
             (add-weight (pos-tagger-weights tagger) feature class val))
           ))
    (incf (pos-tagger-update-count tagger))
    (unless (eq truth guess)
      (for (feature :across features)
           (upd feature truth 1)
           (upd feature guess -1)))))

(defun average-weights (tagger)
  (declare (optimize (space 0) (speed 3) (safety 0) (float 0)))
  (for* (type type-table :in-table (pos-tagger-weights tagger))
        (specializer specializer-table :in-table type-table)
        (value value-table :in-table specializer-table)
        (class :in-hash-keys value-table)
        (let* ((feature (vector type specializer value))
               (last-update (get-weight (pos-tagger-last-updates tagger) feature class))
               (lived-cycle (- (pos-tagger-update-count tagger) last-update)))
          (add-weight (pos-tagger-living-weights tagger) feature class
                      (* lived-cycle (get-weight (pos-tagger-weights tagger) feature class)))
          (let ((living-weight (get-weight (pos-tagger-living-weights tagger) feature class)))
            (set-weight (pos-tagger-weights tagger) feature class
                        (/ living-weight (pos-tagger-update-count tagger)))))))

(defun train (tagger save-dir sentences &optional (cycles 5))
  (declare (optimize (speed 3) (space 0) (safety 0)))
  (log-info "Start training with ~D sentences, ~D cycles. Current heap size: ~A"
            (length sentences) cycles (print-size (getf (sys:room-values) :total-size)))
  (for (cycle :range cycles)
       (let ((prev-tag         'start)
             (prev-prev-tag    'start)
             (correct-count    0)
             (total-count      0)
             (cycle-start-time (get-internal-real-time)))
         (for (words :across sentences)
              (for (word :across words)
                   (truth    = (word-upos word))
                   (features = (collect-features word words prev-tag prev-prev-tag))
                   (guess    = (predict tagger features))
                   (update tagger truth guess features)
                   (when (eq guess truth) (incf correct-count))
                   (incf total-count)
                   (setq prev-prev-tag prev-tag
                         prev-tag guess)))
         (shuffle sentences)
         (log-info "Cycle ~D/~D completed using ~,2Fs with ~D/~D (~,2F%) correct. Heap size: ~A"
                   (1+ cycle) cycles (/ (- (get-internal-real-time) cycle-start-time) 1000)
                   correct-count total-count (* 100 (/ correct-count total-count))
                   (print-size (getf (sys:room-values) :total-size)))))
  (average-weights tagger)
  (save-tagger tagger save-dir))

(defun test-tagger (tagger sentences)
  (let ((prev-tag 'start)
        (prev-prev-tag 'start)
        (correct-count 0)
        (total-count 0)
        (start-time (get-internal-real-time)))
    (for (words :across sentences)
         (for (word :across words)
              (features = (collect-features word words prev-tag prev-prev-tag))
              (guess = (predict tagger features))
              (truth = (word-upos word))
              (if (or (eq guess truth)
                      (and (member guess '(:noun :propn))
                           (member truth '(:noun :propn))))
                  (incf correct-count)
                ;(log-info "~10<~A~;~> Wrong! Guess: ~A, truth: ~A" (word-form word) guess truth)
                )
              (incf total-count)))
    (log-info "Test ~D sentences using ~,2Fs, result: ~D/~D (~,2F%)"
              (length sentences) (/ (- (get-internal-real-time) start-time) 1000)
              correct-count total-count (* 100 (/ correct-count total-count)))
    (float (* 100 (/ correct-count total-count)))))

(log-config :stream *background-output*)

(defun test-training ()
  (let ((tagger (make-pos-tagger)))
    (train tagger "~/common-lisp/pos/"
           (read-conllu-files #P"~/Downloads/ud-treebanks-v2.14/UD_English-GUM/en_gum-ud-train.conllu"
                            ;#P"~/Downloads/ud-treebanks-v2.14/UD_English-EWT/en_ewt-ud-train.conllu"
                            ;#P"~/Downloads/ud-treebanks-v2.14/UD_English-Atis/en_atis-ud-train.conllu"
                            ;#P"~/Downloads/ud-treebanks-v2.14/UD_English-ParTUT/en_partut-ud-train.conllu"
                              )
           5)
    (test-tagger tagger (read-conllu-file #P"~/Downloads/ud-treebanks-v2.14/UD_English-GUM/en_gum-ud-test.conllu"))
    (setq *loaded-tagger* tagger)))

(export '(train test-training predict))